# 今日总结

- leetcode
  1.[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)----- 快慢指针解决
  2.[134. 加油站](https://leetcode.cn/problems/gas-station/)----- 贪心算法解决

## C++ 高频面试题

### 题目1: 智能指针和RAII
**问题**: 请解释C++11中的智能指针类型（shared_ptr, unique_ptr, weak_ptr），它们的区别和使用场景？什么是RAII？

**关键点**:
- `unique_ptr`: 独占所有权，不可复制，可移动
- `shared_ptr`: 共享所有权，引用计数管理
- `weak_ptr`: 弱引用，解决shared_ptr循环引用问题
- RAII: Resource Acquisition Is Initialization，资源获取即初始化

#### 智能指针内部实现机制详解

**1. unique_ptr 内部结构**:
```cpp
template<typename T>
class unique_ptr {
private:
    T* ptr_;  // 只存储一个原始指针，8字节
public:
    // 禁止拷贝，只允许移动
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr(unique_ptr&& other) noexcept;  // 移动构造
};
```
- **大小**: 8字节（与原始指针相同）
- **零开销抽象**: 编译器优化后性能等同原始指针
- **所有权转移**: 通过移动语义实现，确保独占

**2. shared_ptr 内部结构**:
```cpp
template<typename T>
class shared_ptr {
private:
    T* ptr_;                    // 指向管理的对象 (8字节)
    ControlBlock* control_;     // 指向控制块 (8字节)
};

struct ControlBlock {
    size_t ref_count;    // 强引用计数
    size_t weak_count;   // 弱引用计数
    T* ptr;              // 管理的对象指针
    // 删除器、分配器等...
};
```
- **大小**: 16字节（是原始指针的2倍）
- **引用计数**: 控制块中维护强/弱引用计数
- **线程安全**: 引用计数操作是原子的
- **内存布局**: 对象 + 控制块分离存储

**3. weak_ptr 内部结构**:
```cpp
template<typename T>
class weak_ptr {
private:
    T* ptr_;                    // 指向管理的对象 (8字节)
    ControlBlock* control_;     // 指向相同的控制块 (8字节)
};
```
- **大小**: 16字节（与shared_ptr相同）
- **不影响生命周期**: 不增加强引用计数
- **安全访问**: lock()方法获取临时shared_ptr
- **打破循环**: 解决shared_ptr循环引用问题

**内存开销对比表**:
| 指针类型 | 大小 | 额外开销 | 运行时开销 |
|----------|------|----------|------------|
| 原始指针 T* | 8字节 | 无 | 无 |
| unique_ptr<T> | 8字节 | 无 | 零开销 |
| shared_ptr<T> | 16字节 | ControlBlock | 原子操作 |
| weak_ptr<T> | 16字节 | 共享ControlBlock | lock()开销 |

**循环引用问题详解**:
```cpp
// ❌ 错误：循环引用导致内存泄漏
class Parent {
    shared_ptr<Child> child;  // 强引用
};
class Child {
    shared_ptr<Parent> parent;  // 强引用 ← 问题！
};

// ✅ 正确：使用weak_ptr打破循环
class Parent {
    shared_ptr<Child> child;  // 强引用
};
class Child {
    weak_ptr<Parent> parent;  // 弱引用 ← 解决方案！
};
```

**使用场景详细对比**:

🔐 **unique_ptr 使用场景**:
- **独占资源所有权**：文件句柄、网络连接
- **函数返回堆对象**：工厂模式、Builder模式
- **PIMPL惯用法**：隐藏实现细节
- **容器中存储多态对象**：`vector<unique_ptr<Base>>`
- **零开销要求**：性能敏感的场景

🤝 **shared_ptr 使用场景**:
- **多个对象共享资源**：配置对象、缓存数据
- **复杂生命周期**：对象所有者不明确
- **多线程共享**：线程间传递对象
- **观察者模式**：多个观察者共享主题
- **图结构**：节点间相互引用

🔗 **weak_ptr 使用场景**:
- **打破循环引用**：父子关系、双向链表
- **观察者模式**：观察者持有主题的弱引用
- **缓存系统**：缓存项的临时引用
- **回调函数**：避免回调对象已销毁
- **安全检查**：检查对象是否仍然存在

**面试金句总结**:
- **unique_ptr**: "独占 + 零开销 + 移动语义"
- **shared_ptr**: "共享 + 引用计数 + 线程安全"  
- **weak_ptr**: "观察 + 打破循环 + 安全访问"
- **选择原则**: "能用unique就用unique，需要共享才用shared"

### 题目2: 虚函数和多态
**问题**: 虚函数的实现机制是什么？虚函数表在哪里？纯虚函数和抽象类有什么区别？

**关键点**:
- 虚函数表(vtable)存储在类的静态存储区
- 每个对象包含指向虚函数表的指针(vptr)
- 纯虚函数使类成为抽象类，不能被实例化
- 动态绑定在运行时决定调用哪个函数

#### 虚函数 vs 纯虚函数详细解析

**语法区别**:
```cpp
// 虚函数 - 有实现体
virtual void makeSound() const {
    cout << name_ << " makes some sound" << endl;
}

// 纯虚函数 - 后面有 = 0，无实现体
virtual void move() const = 0;
```

**功能对比表**:
| 特性 | 虚函数 (Virtual Function) | 纯虚函数 (Pure Virtual Function) |
|------|---------------------------|-----------------------------------|
| **实现** | ✅ 有默认实现 | ❌ 无实现，只有声明 |
| **子类重写** | 🔄 可选择重写 | ⚠️ **必须**重写 |
| **类实例化** | ✅ 可以实例化 | ❌ 包含纯虚函数的类不能实例化 |
| **用途** | 提供默认行为 | 定义接口契约 |

**使用场景**:

🎨 **虚函数适用于**:
- 提供默认行为，子类可以选择重写
- 大部分子类使用相同逻辑，少数需要特殊处理

🔧 **纯虚函数适用于**:
- 接口设计 - 定义契约
- 强制子类实现特定功能
- 不同子类必须有不同实现的场景

**面试重点**:
1. **抽象类概念**: 包含纯虚函数的类是抽象类，不能实例化
2. **继承契约**: 纯虚函数强制子类实现，虚函数提供可选重写
3. **多态机制**: 两者都支持多态，但用途不同
4. **接口设计**: 纯虚函数常用于定义接口（如Java中的interface）

**记忆口诀**:
```cpp
virtual void func() { ... }     // 虚函数：有默认，可重写
virtual void func() = 0;        // 纯虚函数：无实现，必须写
```

**一句话总结**: 
- **虚函数** = "我提供默认实现，你可以选择重写"
- **纯虚函数** = "我只定义接口，你必须实现"

### 题目3: explicit关键字
**问题**: explicit关键字的作用是什么？为什么要使用它？

**核心作用**:
`explicit`关键字用于**防止隐式类型转换**，只能修饰构造函数和转换运算符。

**主要功能**:
1. **防止隐式转换**: 禁止编译器自动进行类型转换
2. **提高代码安全性**: 避免意外的类型转换导致的错误
3. **增强代码可读性**: 强制显式调用，让代码意图更明确
4. **避免二义性**: 防止编译器在多个构造函数间产生歧义

**使用场景**:
- **单参数构造函数**: 防止隐式转换最常见的场景
- **多参数构造函数**: C++11后也可以使用explicit
- **转换运算符**: 如`operator bool()`等
- **智能指针**: 如`unique_ptr(T* p)`构造函数

**典型问题场景**:
```cpp
class String {
public:
    String(int size);        // ❌ 可能发生隐式转换
    explicit String(int size); // ✅ 必须显式调用
};

// 没有explicit的问题：
void func(String s) { }
func(42);  // ❌ 隐式转换：int -> String，可能不是期望行为

// 有explicit的正确行为：
func(String(42));  // ✅ 必须显式构造，意图明确
```

**在智能指针中的应用**:
- `unique_ptr(T* ptr)`使用explicit避免意外的原始指针转换
- `shared_ptr(T* ptr)`同样使用explicit确保显式构造
- 布尔转换`operator bool()`通常也用explicit

**面试要点**:
1. **定义**: 防止隐式类型转换的关键字
2. **适用**: 构造函数和转换运算符
3. **目的**: 提高类型安全和代码清晰度
4. **最佳实践**: 单参数构造函数建议使用explicit
5. **现代C++**: C++11后可用于多参数构造函数

**一句话总结**: 
`explicit`让类型转换从"悄悄进行"变成"明确表达"，提高代码安全性和可读性。

## 今日练习代码文件
- `134.cpp` - 加油站问题（贪心算法 + 调试版本）
- `cpp_interview_demo.cpp` - C++面试重点概念演示
- `virtual_demo.cpp` - 虚函数和纯虚函数详细演示
- `polymorphism_demo.cpp` - 多态机制完整演示
- `vtable_detailed.cpp` - 虚函数表内部机制详解
- `destructor_demo.cpp` - 虚析构函数重要性演示
- `smart_pointers_detailed.cpp` - 智能指针内部实现机制详解

