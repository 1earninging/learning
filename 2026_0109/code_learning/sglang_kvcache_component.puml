@startuml
title SGLang - KVCache + RadixCache/HiCache（组件视图）

skinparam componentStyle rectangle
skinparam wrapWidth 240
skinparam maxMessageSize 120

package "SGLang Runtime (srt)" {
  [Scheduler] as sched
  [ModelRunner] as runner

  package "Memory Pools" {
    [ReqToTokenPool\n(req_slot -> token_pos -> loc)] as r2t
    [TokenToKVPoolAllocator\n(Token/ Paged)] as alloc
    [KVCache (TokenToKVPool)\n(MHA/MLA/Hybrid/SWA/NSA...)] as kvc
  }

  package "Prefix Cache" {
    [RadixCache (RadixTree)] as radix
  }

  package "HiCache (可选)" {
    [HiRadixTree\n(L1/L2 metadata)] as hiradix
    [L2 HostKVCache\n(page_first/...)] as l2
    [L3 Storage Backend\n(Mooncake/NIXL/3FS/AIBrix/...)] as l3
  }

  package "PD Disaggregation (可选)" {
    [Prefill KV Sender] as sender
    [Decode KV Receiver] as receiver
    [Transfer Backend Manager] as tbm
  }
}

package "Attention Backend" {
  [Attention Kernel] as attn
}

runner --> r2t : 写入/读取 loc 映射
runner --> alloc : alloc_extend()/alloc_decode()
alloc --> kvc : loc -> 写入/读取 KV
runner --> attn : attention 使用 loc 访问 KV

radix --> r2t : match_prefix() 命中后\n拿到 device indices
radix --> alloc : miss/evict 时 free/alloc indices

hiradix --> radix : local match（L1/L2）
hiradix --> l3 : query/exists（按需）
hiradix --> l2 : prefetch / write-back

sender --> tbm : init(kv_ptrs/lens)\nsend(page_indices, state_indices)
receiver --> tbm : init(page_indices)\nrecv -> 写入 KV buffer

note bottom of r2t
  关键数据结构：
  req_to_token[req_pool_idx, t] = kv_loc
  kv_loc 由 allocator 分配（page-aligned 支持）
end note

note bottom of hiradix
  HiCache：L1 GPU / L2 Host / L3 Storage
  - local match
  - prefetch（best_effort/timeout/wait_complete）
  - write-back（write_back/write_through/...）
end note

@enduml


