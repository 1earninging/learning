@startuml
title SGLang - PD Disaggregation（prefill->decode）KV 传输时序

skinparam maxMessageSize 160
skinparam sequenceMessageAlign center

participant "Client" as C
participant "Prefill Scheduler\n(SGLang prefill instance)" as P
participant "Prefill ModelRunner\n(ReqToTokenPool+Allocator)" as PR
participant "KV Sender\n(disagg_kv_sender)" as S
participant "Transfer Backend\n(BaseKVManager)\n(Mooncake/NIXL/..)" as X

participant "Decode Scheduler\n(SGLang decode instance)" as D
participant "Decode PreallocQueue\n(req_to_token + allocator)" as PQ
participant "KV Receiver\n(kv_receiver)" as R
participant "Decode TransferQueue" as TQ

== 0. handshake / bootstrap ==
C -> P : request(prompt, bootstrap_host/room,...)
P -> S : bootstrap(handshake)\n(建立通道/交换 metadata)
S -> X : init(kv_data_ptrs/lens/item_lens,\npage_size, state_ptrs,...)

== 1. Prefill：分配 loc 并计算 prefill ==
P -> PR : alloc req_pool_idx\nalloc_extend() 得到 kv_loc
PR -> PR : write(req_to_token[req_slot, t]=kv_loc)
P -> P : run prefill forward\n填充 KV

== 2. Prefill：按 chunk 发送（核心：page_indices） ==
P -> P : kv_indices = req_to_token[req_slot, start:end]
P -> S : send(page_indices,\nstate_indices if last_chunk)
S -> X : transfer pages (RDMA/copy)\n写入 decode 侧预分配区域

== 3. Decode：预分配并启动接收 ==
D -> PQ : pre_alloc(req)\nalloc_extend() 预留 loc
PQ -> R : init(page_indices,\nmetadata_buffer_index,\nstate_indices)
R -> X : recv into pre-allocated pages

== 4. Decode：poll 直到 transferred，变成 prebuilt batch ==
D -> TQ : pop_transferred()\n(poll kv_receiver)
TQ -> D : commit metadata\n(output token/logprob/hidden_states)
D -> D : 构造 PrebuiltExtendBatch\n跳过 prefill 计算，直接进入 decode

@enduml


